---
title: "Avoiding Security Pitfalls"
description: "When building and publishing with Lovable"
icon: "lock"
---

<Note>
**Don't forget to fix Security Checker findings**

Make sure to address Lovable's built-in [security checker](#using-lovable-s-security-checker) findings before publishing your app online. The security checker automatically scans your application and provides valuable recommendations for improving security.
</Note>

To build apps that can thrive on the internet without exposing sensitive data and business logic flaws, it's crucial to understand the architecture and implement proper security practices from the start.

## Understanding Lovable's Architecture

Lovable generates applications with the following architecture:

- **Frontend**: TypeScript/React application
- **Backend**: Supabase Edge Functions (serverless functions)
- **Database**: Supabase (PostgreSQL with real-time capabilities)

This separation of concerns is fundamental to maintaining security. Each layer has specific responsibilities and security considerations.

## Frontend Security: Never Trust Client-Side Code

### The Golden Rule: Frontend Code is Public

All React code runs in the user's browser and is inherently public. Users can inspect, modify, or bypass any frontend code. Therefore:

- **Never store secrets in frontend code** - API keys, passwords, or sensitive configuration
- **Never perform validation in frontend code** - Client-side validation can be bypassed
- **Never trust frontend data** - Always validate on the edge functions' side

### Common Frontend Security Mistakes

```typescript
// ❌ WRONG - Never do this
const API_KEY = "sk-1234567890abcdef"; // Exposed to users
const validateUser = (userData) => {
  // Client-side validation can be bypassed
  return userData.email.includes('@');
};
```

Correct way is to ask Lovable to add a secret key - it will open a form, and store the secret securely in its own backend.

## Backend Security: Move Business Logic to Edge Functions

### Treat Edge Functions as Your API Layer

Supabase Edge Functions should contain all your business logic, validation, and sensitive operations:

- **Authentication and authorization**
- **Data validation and sanitization**
- **Business logic and workflows**
- **Integration with external services**
- **Sensitive data processing**

### Best Practices for Edge Functions

Think of edge functions as your application's security guards and business managers. They handle all the important work that needs to be done safely, away from the public-facing parts of your app.

#### What Edge Functions Should Handle

**User Authentication & Authorization**
- Always verify that users are who they claim to be before allowing them to perform actions
- Check if users have the right permissions for specific operations
- Never trust that someone is logged in just because they say they are

**Data Validation & Sanitization**
- Check all incoming data to make sure it's in the correct format
- Remove any potentially harmful content from user inputs
- Ensure data meets your business rules before processing it

**Business Logic & Workflows**
- Handle complex business processes like order processing, payment calculations, or user registration
- Manage relationships between different pieces of data
- Coordinate multiple steps in a single operation

**External Service Integration**
- Safely connect to third-party services like payment processors, email providers, or APIs
- Keep sensitive API keys and credentials secure
- Handle errors and timeouts gracefully

**Sensitive Data Processing**
- Process personal information, financial data, or other sensitive content
- Apply encryption or other security measures when needed
- Log important events for security auditing

#### Security Benefits of Edge Functions

**Isolation**: Edge functions run in a secure environment separate from your frontend, making it much harder for attackers to access sensitive code or data.

**Centralized Security**: All security checks happen in one place, making it easier to maintain and update security policies.

**No Client-Side Exposure**: Sensitive business logic never reaches the user's browser, where it could be viewed or modified.

**Consistent Validation**: Every request goes through the same validation process, ensuring consistent security across your application.

## Database Security: Keep RLS Simple and Start Early

### Row Level Security (RLS) in Lovable

Lovable automatically sets up basic RLS policies for your tables, but you should review and customize them based on your app's security needs. Think of RLS as the rules that determine who can see and modify which pieces of data in your database.

**Early Review is Critical**: It's much easier to adjust RLS policies when your app is new rather than after users have already created data.

**Simple is Secure**: Keep RLS policies simple and focused on data access, not complex business logic. Lovable's default policies are usually a good starting point.

#### Common RLS Patterns in Lovable Apps

**Personal Data Protection**
- Users should only see their own profile, settings, and personal data
- Default pattern: "Users can only access their own data"

**Team-Based Access**
- Team members can see shared project data within their team
- Pattern: "Users can access data from teams they belong to"

**Public Content with Ownership**
- Public posts that anyone can read, but only owners can edit
- Pattern: "Anyone can read, only owners can modify"

**Organization-Based Access**
- Company employees can access company data
- Pattern: "Users can access data from their organization"

#### Reviewing RLS in Your Lovable App

**Check Your Tables**
- Review which tables have RLS enabled
- Verify that sensitive data tables are protected
- Ensure public data tables have appropriate read policies

**Test Access Patterns**
- Verify users can only see their own data
- Test that shared data is accessible to the right people
- Confirm that public data is visible to everyone

**Common Issues to Look For**
- Tables without RLS enabled on sensitive data
- Overly permissive policies that expose too much data
- Missing policies for new tables or features

#### Prompt Examples for RLS Review

**Review Current RLS Setup:**
"Can you review the RLS policies in my Lovable app? I want to make sure users can only access their own data and that shared data is properly protected."

**Check Specific Table Security:**
"I have a users table and a posts table. Can you check if the RLS policies are set up correctly so users can only see their own profile but can read all public posts?"

**Add Missing Security:**
"I noticed my settings table doesn't have RLS enabled. Can you add policies so users can only access their own settings?"

**Fix Overly Permissive Access:**
"Users can currently see all posts from all users. I want to restrict this so users can only see their own posts and public posts. Can you update the RLS policies?"

**Team-Based Security:**
"I have teams and projects tables. Can you set up RLS so team members can only see projects from their own team?"

**Organization Security:**
"My app has organizations and users belong to companies. Can you ensure users can only access data from their own organization?"

**Review for Data Leaks:**
"Can you audit my RLS policies to make sure there are no security holes where users might access data they shouldn't see?"

**Simplify Complex Policies:**
"The RLS policies in my app seem overly complex. Can you simplify them while maintaining security?"

#### Quick RLS Checklist

- [ ] All sensitive tables have RLS enabled
- [ ] Users can only access their own personal data
- [ ] Shared data has appropriate access controls
- [ ] New tables automatically get RLS policies
- [ ] Policies are simple and easy to understand

## Authentication Security: Avoid Local Storage

### Never Use Local Storage for Sensitive Data

Local storage is accessible to any JavaScript code running on your domain and can be easily bypassed:

- **Never store authentication tokens in localStorage**
- **Never store sensitive user data in localStorage**
- **Never store API keys or secrets in localStorage**

### Secure Authentication Flow

```typescript
// ❌ WRONG - Using localStorage for auth
localStorage.setItem('authToken', token);
localStorage.setItem('userData', JSON.stringify(userData));

// ✅ CORRECT - Use secure session management
// Let Supabase handle authentication state
const { data: { session } } = await supabase.auth.getSession();
```

## Workspace Protection: Secure Internal Applications

### Mark Internal Apps as Protected

For applications that should not be publicly accessible:

- **Mark internal apps as "Protected" in your workspace**
- **Verify they are not published to the internet**
- **Use proper authentication for all internal tools**
- **Regularly audit access to protected applications**

### Workspace Security Checklist for Enterprise users

- [ ] All internal apps should be marked as "Protected"
- [ ] No sensitive applications published publicly
- [ ] Proper authentication required for all internal tools
- [ ] Regular access reviews conducted
- [ ] Clear documentation of which apps are internal vs. public

## Security Best Practices Summary

### Development Workflow

1. **Start with security in mind** - Implement RLS and authentication from day one
2. **Use the security checker** - Run Lovable's security checker regularly
3. **Follow recommendations** - Implement all security suggestions
4. **Test thoroughly** - Verify security measures work as expected
5. **Document security decisions** - Keep track of security choices and rationale

### Regular Security Audits

- **Review edge function permissions**
- **Audit RLS policies**
- **Check for exposed secrets**
- **Verify authentication flows**
- **Test access controls**

### Common Security Checklist

- [ ] No secrets in frontend code
- [ ] All validation in edge functions
- [ ] RLS policies implemented and tested
- [ ] Authentication using secure methods
- [ ] Internal apps properly protected
- [ ] Security checker run and recommendations followed
- [ ] Regular security reviews conducted

## Using Lovable's Security Checker

Lovable provides a built-in [security checker](/features/security#security-scanning-2) to help identify potential security issues:

1. **Run the security checker** in your project dashboard
2. **Review all recommendations** carefully
3. **Implement suggested fixes** promptly
4. **Re-run the checker** after making changes
5. **Document any exceptions** with clear rationale

Remember: Security is not a one-time task but an ongoing process. Regularly review and update your security measures as your application evolves. 
